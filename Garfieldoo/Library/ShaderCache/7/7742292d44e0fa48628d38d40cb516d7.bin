=this._breakIntoSpecificWorkerIds[t]){this._breakIntoSpecificWorkerIds.splice(t,1);return!0}return!1}flushMessageQueue(e,t){if(e.length>0)switch(t){case"onAddDocuments":case"onRemoveDocuments":case"onUpdateDocuments":this._callHandler.notify(t,e);e.length=0;break;default:r.a.fail("Batching of '"+t+"' messages isn't supported.")}}onAddDocuments(e){const t=[];for(const i of e){if(i.url&&i.url.match(c)){this._initialDocumentDocId=i.docId;continue}this._documentMap.set(i.docId,{url:i.url,start:0,length:i.length});const e=i.parentDocId===this._initialDocumentDocId,r=this.getSourceText(String(i.docId)).text;let n={sourceMap:null,sourceUrl:null};"text/html"!==i.mimeType.toLowerCase()&&(n=a(r,i.isDynamicCode));const s={id:String(i.docId),isDynamicCode:i.isDynamicCode,length:i.length,longDocumentId:String(i.longDocumentId),mimeType:i.mimeType,parentId:String(i.parentDocId),sourceMapUrl:i.sourceMapUrlFromHeader||n.sourceMap,sourceUrlOverride:n.sourceUrl,url:i.url};t.push(s);if(e)if(this._documentMap.size>0){this.flushMessageQueue(t,"onAddDocuments");this._rootDocId=i.docId;this._callHandler.notify("onSetRootDocument",[String(i.docId)])}else this._rootDocIdQueue.push(i.docId)}this.flushMessageQueue(t,"onAddDocuments")}onRemoveDocuments(e){const t=[];for(const i of e){this._documentMap.delete(i);delete this._lastSourceUpdateMap[i];const e=this._rootDocIdQueue.indexOf(i);e>-1&&this._rootDocIdQueue.splice(e,1);i!==this._initialDocumentDocId&&t.push(String(i));if(i===this._rootDocId&&this._rootDocIdQueue.length>0&&this._documentMap.has(this._rootDocIdQueue[0])){this._rootDocId=this._rootDocIdQueue[0];this.flushMessageQueue(t,"onRemoveDocuments");this._rootDocId&&this._callHandler.notify